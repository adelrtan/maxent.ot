% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/optimize.R
\name{optimize_weights}
\alias{optimize_weights}
\title{Optimize MaxEnt OT constraint weights}
\usage{
optimize_weights(
  input_file,
  bias_file = NA,
  mu_scalar = NA,
  mu_vector = NA,
  sigma_scalar = NA,
  sigma_vector = NA,
  input_format = "otsoft",
  in_sep = "\\t",
  control_params = NA,
  upper_bound = DEFAULT_UPPER_BOUND,
  model_name = NA
)
}
\arguments{
\item{input_file}{The path to the input data file. This file contains one or
more OT tableaux consisting of mappings between underlying and surface
forms with observed frequency and violation profiles. Constraint
violations must be numeric.}

\item{bias_file}{(optional) The path to the file containing mus and sigma
for constraint biases. If this argument is provided, the scalar and vector
mu and sigma arguments will be ignored. Each row in this file should be the
name of the constraint, followed by the mu, followed by the sigma
(separated by whatever the relevant separator is; default is tabs).}

\item{mu_scalar}{(optional) A single scalar value that will serve as the mu
for each constraint in the bias term. Constraint weights will also be
initialized to this value. This value will not be used if either
\code{bias_file} or \code{mu_vector} are provided.}

\item{mu_vector}{(optional) A vector of mus for each constraint in the bias
term. The length of this vector must equal the number of constraints in
the input file. If \code{bias_file} is provided, this argument will be
ignored. If this argument is provided, \code{mu_scalar} will be ignored.}

\item{sigma_scalar}{(optional) A single scalar value that will serve as the
sigma for each constraint in the bias term. This value will not be used if
either \code{bias_file} or \code{sigma_vector} are provided.}

\item{sigma_vector}{(optional) A vector of sigmas for each constraint in the
bias term. The length of this vector must equal the number of constraints
in the input file. If \code{bias_file} is provided, this argument will be ignored.
If this argument is provided, \code{sigma_scalar} will be ignored.}

\item{input_format}{(optional) A string specifying the format of the input
files. Currently only OTSoft-style formatting is supported. Defaults to
'otsoft'.}

\item{in_sep}{(optional) The delimiter used in the input files. Defaults to
tabs.}

\item{control_params}{(optional) A named list of control parameters that
will be passed to the \link[stats]{optim} function. See the documentation
of that function for details. Note that some parameter settings may
interfere with optimization. The parameter \code{fnscale} will be overwritten
with \code{-1} if specified, since this must be treated as a maximization
problem.}

\item{upper_bound}{(optional) The maximum value for constraint weights.
Defaults to 1000.}

\item{model_name}{(optional) A name for the model. If not provided, the file
name will be used.}
}
\value{
An object with the following named attributes:
\itemize{
\item \code{weights}: A named list of the optimal constraint weights
\item \code{log_lik}: the log likelihood of the data under the discovered
weights
\item \code{k}: the number of constraints
\item \code{n}: the number of data points in the training set
}
}
\description{
Optimizes constraint weights given a data set and optional biases. If no
bias arguments are provided, the bias term(s) will not be included in the
optimization.
}
\details{
By default, this function maximizes the log likelihood of the training data
by changing the values of \eqn{w}, the vector of constraint weights. The log
likelihood of the training data \eqn{D} is

\deqn{LL_w(D) = \sum_{i=1}^{n}{\ln P(y_i|x_i; w)}
- \sum_{k=1}^{m}{\frac{(w_k - \mu_k)^2}{2\sigma_k^2}}}

The first term in this equation calculates the likelihood of the training
data under the weights \eqn{w}. \eqn{n} is the number of data points
(i.e., the sample size or the sum of the frequency column in the input),
\eqn{x_i} is the input form of the \eqn{i}th data point, and \eqn{y_i} is
the observed surface form corresponding to \eqn{x_i}. \eqn{P(y_i|x_i; w)}
represents the probability of realizing underlying \eqn{x_i} as surface
\eqn{y_i} given weights \eqn{w}. This probability is defined as

\deqn{P(y_i|x_i; w) = \frac{1}{Z_w(x_i)}\exp(\sum_{k=1}^{m}{w_k f_k(y_i, x_i)})}

where \eqn{f_k(y_i, x_i)} is the number of violations of constraint \eqn{k}
incurred by mapping underlying \eqn{x_i} to surface \eqn{y_i}. \eqn{Z_w(x_i)}
is a normalization term defined as

\deqn{Z(x_i) = \sum_{y\in\mathcal{Y}(x_i)}{\exp(\sum_{k=1}^{m}{w_k f_k(y, x_i)})}}

where \eqn{\mathcal{Y}(x_i)} is the set of observed surface realizations of
input \eqn{x_i}.

The second term of the equation for calculating log likelihood is the bias
term, where where \eqn{w_k} is the weight of constraint \eqn{k}, and
\eqn{\mu_k} and \eqn{\sigma_k} parameterize a normal distribution that
serves as a prior for the value of \eqn{w_k}. Values of \eqn{w_k} that
deviate from \eqn{\mu_k} decrease the log likelihood function proportionally
to \eqn{\sigma_k}: lower values of \eqn{\sigma_k} penalize deviations from
\eqn{\mu_k} more severely.

A general bias with \eqn{\mu_k = 0} for all \eqn{k} is commonly used as a
form of simple regularization to prevent overfitting (see, e.g., Goldwater
and Johnson 2003). Bias terms have also been used to model proposed
phonological learning biases; see for example Wilson (2006), White (2013),
and Mayer (2021, Ch. 4). The choice of \eqn{\sigma} depends on the sample
size. As the number of data points increases, \eqn{\sigma} must decrease in
order for the effect of the bias to remain constant: specifically,
\eqn{n\sigma^2} must be held constant, where \eqn{n} is the number of tokens.

Optimization is done using the \link[stats]{optim} function from the R-core
statistics library. By default it uses \code{L-BFGS-B} optimization, which is a
quasi-Newtonian method that allows upper and lower bounds on variables.
Constraint weights are restricted to finite, non-negative values.

If no bias parameters are specified (either the \code{bias_file} argument or some
combination of the scalar/vector mu/sigma parameters), optimization will be
done without the bias term.
}
\examples{
  # Get paths to toy data and bias files.
  data_file <- system.file(
      "extdata", "sample_data_file.txt", package = "maxent.ot"
  )
  bias_file <- system.file(
      "extdata", "sample_bias_file.txt", package = "maxent.ot"
  )

  # Fit weights to data with no biases
  optimize_weights(data_file)

  # Fit weights with biases specified in file
  optimize_weights(data_file, bias_file)

  # Fit weights with biases specified in vector form
  optimize_weights(
      data_file, mu_vector = c(1, 2), sigma_vector = c(100, 200)
  )

  # Fit weights with biases specified as scalars
  optimize_weights(data_file, mu_scalar = 0, sigma_scalar = 1000)

  # Fit weights with mix of scalar and vector biases
  optimize_weights(data_file, mu_vector = c(1, 2), sigma_scalar = 1000)

  # Pass additional arguments to optim function
  optimize_weights(data_file, control_params = list(maxit = 500))

}
